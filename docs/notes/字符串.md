
# 字符串相关

## `str`
`str` 是一个字符串类型的原始定义，是 Rust 语言级别类型。由双引号 `"` 包围的固定长度不可修改的字符串序列。

**字符串字面量被硬编码进可执行的二进制文件中，存放在程序的只读数据段中，不能被修改，也不能被扩展长度**，它们被放在独立于栈和堆的空间中（可以理解为字符串常量区）。这使得字符串字面量快速且高效，这主要得益于字符串字面量的不可变性。

当**当我们在 Rust 代码中使用字符串字面量时，编译器会将它们转换为`&str`类型的字符串切片（即，对字符串字面量的引用）**，且隐式具有`'static`生命周期。

这是因为字符串字面量在 Rust 中是静态分配的，也就是说，**它们的值在编译时已经确定**。相比之下，动态分配的字符串类型 String 在运行时进行内存分配和释放，因此在性能上会有一些开销。

## `&str`
`&str` 是一个对 `str` 的切片引用，可以访问 `str` 中的一部分字符，具有只读权限；

对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

`hello`没有引用整个String `s`，而是引用`s`的一部分内容，通过`[0..5]`的方式来指定。

这就是创建切片的语法，使用方括号包括的一个序列：`[开始索引.. 终止索引]`，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个 右半开区间。

在切片数据结构内部会保存开始的位置和切片的长度，其中长度是通过 终止索引 - 开始索引 的方式计算得来的。

对于`let world = &s[6..11];`来说，`world`是一个切片，该切片的指针指向`s`的第 7 个字节 (索引从 0 开始，6 是第 7 个字节)，且该切片的长度是`5`个字节。

## `String`
`String`是 Rust 标准库提供的一个可增长、可改变且具有所有权的 UTF-8 编码字符串，存储在堆上，并且可以动态地分配和释放内存。

```rust
fn main() {
    let s = String::from("Hello");
    //   let b = &mut a;
    let a = s;
    println!("{a:?}");
}
```

`s`依然可以读取，但是若不加`mut`，赋值后，值就不能改了。

**因此，使用 `str` 类型通常是比较少见的。大多数情况下我们会使用 `&str` 或 `String` 类型来处理字符串数据，具体取决于我们的需求和场景**。
通常，如果我们需要处理不可变的静态字符串，比如文本常量或者字面量，就可以使用 `&str` 类型；如果我们需要处理可变的动态字符串，则可以使用 `String` 类型。

当 Rust 用户提到字符串时，往往指的就是`String`类型和`&str`字符串切片类型，这两个类型都是 UTF-8 编码。

需要注意的是，由于 `String` 类型是可变的，因此它比 `&str` 类型更加灵活和方便。但同时也需要注意，由于 `String` 类型是动态分配内存的，所以使用时需要特别关注内存的分配和释放，避免出现性能问题。

除了 String 类型的字符串，Rust 的标准库还提供了其他类型的字符串，例如 OsString， OsStr， CsString 和 CsStr 等，注意到这些名字都以 String 或者 Str 结尾了吗？它们分别对应的是具有所有权和被借用的变量。

## `[T]`类型
`[T]` 类型表示一个元素类型为 `T` 的切片（slice），它是由一系列类型相同的值组成的动态长度序列。这个区间可以是一个数组的一部分，也可以是一个动态分配的缓冲区。
切片类型的大小是运行时确定的，并且可以通过指针访问任意内存位置的一段连续内存区域作为数据来源。因此，它比数组更具有实用价值。

和其他切片类型一样，`[T]` 类型实际上是一个包含有关引用和长度的元数据结构。它们在编译时被推导出来：

- 长度（Length）：切片包含的元素数量。
- 指针（Pointer）：指向首元素的指针，这个指针是可变的。

在 Rust 中，切片类型是不可变的，它们引用底层数组的一部分连续元素，并具有固定长度。因此，切片容纳元素的数量与其长度（即 `len()` 方法返回值）相同。

当然，如果底层数组还有额外空间，我们可以使用特殊的类型 `&mut [T]` 更新切片中已经存在的元素或者添加新元素以增加切片大小。

如果您使用的是动态可变向量类型 `Vec<T>`，当其内部的缓冲区空间占满时，`Vec` 会自动将其内存扩展到指定大小（例如两倍于当前大小），并将所有元素复制到新的内存中。这样，您就可以在扩展后的 `Vec` 中容纳更多的元素。扩展 `Vec` 内存的过程称为“重新分配”。

**由于切片只是一小段内存的引用，因此它不属于被分配给切片的内存区域**。当切片离开作用域时，不需要释放任何内存，以免出现两次释放同一块内存导致程序错误。

这个类型在 Rust 中非常常见，它广泛应用于各种场景，例如：

- 处理文件和网络数据时，可以使用 `[u8]` 类型的切片来读写二进制数据。
- 在某些算法实现中，可以使用 `[T]` 类型的切片来表示输入和输出数据。
- 在实现自定义集合类型时，可以使用 `[T]` 类型的切片来存储元素。

总而言之，切片类型在 Rust 中使用非常广泛，我们可以看到几乎所有基于集合的 API 都提供了用于处理切片数据的方法和函数。该类型的动态长度特性使得它能够更加灵活地处理变长数据结构，也为快速访问大型数据集合提供了可靠而高效的方法。

## DST
在 Rust 中，DST (Dynamic Sized Type) 指的是类型大小在运行时才能确定的类型，这种类型通常是通过指针、切片和 trait 对象来实现的。

一个例子是 Rust 中的 `str` 类型。在 Rust 中，`str` 表示一段 UTF-8 编码的文本，由于每个字符的大小都不同，因此该类型的大小只能在运行时确定。在内存中，`str` 类型实际上是一个指向字符串内存的指针和一个长度字段的元组 `(ptr: *const u8, len: usize)`。

另一个例子是切片类型 `[T]`。在 Rust 中，切片表示对一个数组或向量的引用，由于数组或向量的长度在编译时未知，因此切片的大小只能在运行时确定。在内存中，切片类型实际上是一个指向数组或向量内存的指针和一个长度字段的元组 `(ptr: *const T, len: usize)`。

这些类型的大小只能在运行时确定，因此需要特殊的语法和机制来处理它们，例如使用裸指针和特殊的 trait。
Rust 还提供了 `Sized` trait 来限制泛型参数必须是静态大小类型，从而保证编译时可以确定类型的大小。

好的，我们可以使用一个例子来说明 Rust 中动态大小类型的使用。

```rust
fn main() {
    let s1 = "hello"; // 字符串字面量
    let s2 = String::from("world"); // 动态分配的字符串

    print_str(s1);
    print_str(&s2);
}

fn print_str(s: &str) {
    println!("{}", s);
}
```

在上面的代码中，我们定义了两个不同类型的字符串 `s1` 和 `s2`。其中，`s1` 是一个字符串字面量，它的大小在编译时已经确定，因此其类型是 `&'static str`；而 `s2` 则是一个动态分配的字符串，其大小只能在运行时确定，因此其类型是 `String`。

接着，我们定义了一个函数 `print_str`，该函数接收一个参数 `s`，类型为 `&str`，即字符串切片类型。在调用该函数时，我们分别将 `s1` 和 `s2` 作为参数传递进去。由于 `s1` 和 `&s2` 都是字符串切片类型，因此它们可以作为函数参数进行传递，而无需考虑其类型大小的问题。

需要注意的是，在函数 `print_str` 内部，我们可以通过 `s.len()` 方法获取字符串切片的长度，但是不能直接对其进行索引访问，例如 `s[0]` 是无法通过编译的，因为编译器无法确定字符串切片的大小。

## 数组和字符串

在 Rust 中，数组和字符串都是一组相同类型的值的集合。它们之间的区别在于，数组是定长的，而字符串通常是不定长的。

具体来说，在 Rust 中，数组长度是固定的，在定义数组时必须指定其元素数量，如`[i32; 5]`表示包含`5`个`i32`类型元素的数组，`a[0]`到`a[4]`将是数组的每个元素。一旦定义了一个数组，就不能直接改变其长度或大小，否则会导致编译错误。

如果操作的是数组切片（`[T]`），则这个整数索引必须是非负整数并小于该数组的长度。而对于字符串切片（`&str`）和字节数组（`[u8]`）而言，由于它们是字节序列，因此索引应该是非负整数且小于该序列的字节长度。

> 需要注意的是，由于 UTF-8 字符集中的每个字符都可能占用不同数量的字节，因此在使用字符串切片（`&str`）时，如果不注意边界问题，可能会导致出现意料之外的行为。在处理字符串时，我们通常建议先确定用于字符串处理的数据类型，并选择相应的数据结构和方法，以确保程序的正确性和安全性。

在 Rust 中，数组的每个元素都占据相同的内存空间。这意味着如果一个数组元素类型是字符串（`String`、`&str` 或 `[u8]` 等），则每个元素都将持有一个指向实际字符串数据的指针。

由于 Rust 的字符串类型代表 Unicode 字符序列，因此字符串的长度可能不同，而这些长度不一致的字符串都需要被存储为单独的、不同大小的内存块。换句话说，虽然具有相同类型的数组元素的内存占用是相等的，但它们可以持有不同长度和内容的字符串数据。当同时打算存储长度不同的字符串时，可以使用动态分配类型 `Vec<String>` 或者使用存储 `&str` 类型的切片类型 `[&str]` 等数据结构。

当使用字符串类型作为数组元素类型时，在内存中的存储方式类似于 String 内存结构。每个数组元素都将包含一个指向实际字符串数据的指针，而这些指针所指向的字符串数据则可能具有不同的长度和内容。

需要注意的是，如果数组元素类型是`&str`或者`[u8]`等其他类型的字符串类型，则指针所指向的字符串数据可能处于不可变状态，这样就可以避免所有者和引用问题。为了防止悬垂指针问题，应该在程序中保证每个指针只引用其指向的字符串数据有效期间内的存储位置。

## Unicode 编码

> Unicode 源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。

因为 Unicode 字符集中包含了许多特殊字符和表情符号等复杂字符，有些字符可能由多个标量值（Unicode Scalar Value）组合而成。比如说，一个 Emoji 表情符号可能由多个标量值组合而成，例如 "👩‍👩‍👧‍👦" 这样的家庭 Emoji 就是由 7 个 Unicode 标量值组合而成的。

"👩‍👩‍👧‍👦" 这个表情符号在 Unicode 中是由五个码位组成的，分别是 U+1F469（👩‍），U+200D（零宽度非连接符，用于描述多个码位组合成一个复杂字符），U+1F469（👩‍），U+200D（零宽度非连接符），U+1F467（👧）和 U+200D（零宽度非连接符），U+1F466 （👦）。总共使用了四个零宽度非连接符 (U+200D) 来连接两个女性和两个孩子这四个人物和形成一个家庭的图案。

```rust
fn main() {
	let c = "\u{1F469}";    // unicode 字符
	let s = "👩‍👩‍👧‍👦".len();
	println!("{} {}",c ,s)
}
```


## `&str`类型的生命周期

对于 `&str` 类型来说，它是一个静态字符串切片，具有 `'static` 生命周期的，意味着它的生命周期会持续整个程序的运行期间。因为**字符串字面量通常作为静态常量存储在程序的只读数据段中，且无法被修改**。

对于 `struct` 类型来说，默认情况下它并不具备 `'static` 生命周期，而是依赖于它的成员变量的生命周期。如果一个结构体的所有成员变量都具有 `'static` 生命周期，那么这个结构体也可以被认为是具有 `'static` 生命周期的。

`&str` 类型表示字符串切片，它引用了程序的静态数据区中的字符串字面量。因为这些字符串字面量的生命周期在整个程序的执行期间都是有效的，所以 `&str` 类型也拥有类似的生命周期。例如，以下代码定义了一个具有 `'static` 生命周期的字符串字面量并将其作为参数传递给一个具有 `'static` 约束的函数：

```rust
fn print_static(s: &'static str) {
    println!("{}", s);
}

fn main() {
    let s: &'static str = "hello";
    print_static(s);
}
```

因此，使用字符串字面量作为参数传递时，通常可以省略`'static`生命周期参数，


`struct` 类型的生命周期取决于其字段的生命周期和所有权关系。如果结构体的所有字段都具有 `'static` 生命周期，则该结构体也具有 `'static` 生命周期。否则，它的生命周期将根据字段之间的生命周期关系和借用规则来确定。然而，如果您希望确保结构体具有 `'static` 生命期，可以通过在结构体定义中添加 `lifetime 'static` 约束来实现：

```rust
struct Person<'a> where 'a: 'static {
    name: &'a str,
    age: u32,
    // ...
}

fn main() {
    let p: Person<'static> = Person {
        name: "Alice",
        age: 30,
        // ...
    };
    // ...
}
```

在这个示例中，我们定义了一个具有 `'static` 生命周期的结构体 `Person`。为了确保该结构体生命周期为 `'static`，我们将其泛型生命周期参数 `'a` 添加到结构体定义中，并使用 `where` 语句来强制指定 `'a: 'static` 约束条件。这确保了在 `Person` 结构体的实例化中，所有引用类型成员都必须是静态的。

需要注意的是，**虽然默认情况下 `&str` 和 `struct` 类型都是具有 `'static` 生命周期的，但如果它们依赖于其他引用类型或具有更短的生命周期，则可能不满足 `'static` 约束条件**。

因此，在编写代码时，请始终考虑到生命周期和所有权关系，以确保程序的内存安全。

## 具有静态生命周期的类型

除了 `&str` 和一些具有 `'static` 生命周期约束的自定义数据类型之外，还有一些其他类型也是具有静态生命周期的。

以下是一些常见的具有 `'static` 生命周期的类型：

- 字符串字面量（例如："hello"）
- 整型、浮点型和字符型字面量（例如：`42`, `3.14`, `'a'`）
- 函数字面量（例如：`fn()`）
- 静态变量（用 `static` 关键字定义）

例如，下面的代码演示了如何使用具有静态生命周期的字符串字面量、函数和静态变量：

```rust
static COUNT: i32 = 0;

fn count() {
    println!("Count: {}", COUNT);
}

fn main() {
    let s: &'static str = "hello";
    println!("{}", s);

    count();
}
```

在这个例子中，我们定义了一个静态变量 `COUNT`，该变量是一个整数字面量，并且其生命周期与整个程序的生命周期一样长。我们还定义了一个具有 `'static` 生命周期的函数 `count()`，该函数输出静态变量 `COUNT` 的值。最后，我们使用字符串字面量 `s` 调用 `println!` 宏，该字符串也具有 `'static` 生命周期。

需要注意的是，在 Rust 中，具有静态生命周期的引用具有编译时确定的生命周期，而不是运行时确定的。因此，使用静态生命周期可以在编译时捕获内存错误，从而提高代码的可靠性和安全性。
