# 13.4 内存不安全示例：悬空指针

我们再使用一个例子，来继续说明为什么 Rust 的“mutation+alias”规则是有必要的。我们这次通过制造一个悬空指针来解释。以下为一段合理的 C++代码，它创建了一个动态数组，然后使用了一个指针，指向了动态数组的内部元素，然后我们向动态数组内添加内容，然后发现原先的指针“悬空”了，它指向了一个非法的地址：

---

```rust
// 以下仅仅为了示例而已，不代表推荐的 C++编码风格
#include <vector>
#include <iostream>

using namespace std;
int main() {
    vector<int> v(100, 5);

    // 指针指向内部第一个元素
    int * p0 = &v[0];
    cout << *p0 << endl;
    // 为了确保 v 发生扩容，多插入一些数据
    for (int i = 0; i<100; i++) {
        v.push_back(10);
    }
    // 打印 p0 的内容
    cout << *p0 << endl;
    return 0;
}
```

---

编译通过，执行结果为：

---

```rust
5
-72140872
```

---

熟悉 STL 的朋友肯定知道这里究竟发生了什么。动态数组是自行管理内存空间的，在向动态数组内部添加元素的时候，如果超过了当前的最大容量，这个动态数组会申请一块更大的连续内存空间，将原来的元素移动过去，释放掉之前的内存空间，然后继续往后面添加元素。

我们的指针一开始是指向动态数组的第一个元素的，但是当往动态数组内部添加多个元素之后，之前的那块内存已经不够用了，动态数组在这个过程中已经将原来的内存空间释放，并申请了新的内存空间。于是，原本应该指向数组第一个元素的指针从一个合法的指针变成了指向已回收内存区域的悬空指针，它现在指向的数据是与原来的意图不同的。而这种情况正是属于 Rust 希望解决的“内存安全”问题。

我们来看看用 Rust 写会发生什么。同样，使用动态数组类型，使用一个指针指向它的第一个元素，然后在原来的动态数组中插入数据：

---

```rust
fn main() {
    let mut arr : Vec<i32> = vec![1,2,3,4,5];
    let p : &i32 = &arr[0];
    for i in 1..100 {
        arr.push(i);
    }
}
```

---

编译不通过，错误信息为：

---

```rust
error: cannot borrow `arr` as mutable because it is also borrowed as immutable
```

---

我们可以看到，“mutation+alias”规则再次起了作用。在存在一个不可变引用的情况下，我们不能修改原来变量的值。写 Rust 代码的时候，经常会有这样的感觉：Rust 编译器极其严格，甚至到了“不近人情”的地步。但是大部分时候却又发现，它指出来的问题的确是对我们编程有益的。对它使用越熟练，越觉得它是一个好帮手。
