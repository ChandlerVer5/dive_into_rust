# 9.3 宏 1.1

对于一些简单的宏，这种“示例型”（by example）的方式足够使用了。但是更复杂的逻辑则需要通过更复杂的方式来实现，这就是所谓的“过程宏”（procedural macro）。它是直接用 Rust 语言写出来的，相当于一个编译器插件。但是编译器插件的最大问题是，它依赖于编译器的内部实现方式。一旦编译器内部有所变化，那么对应的宏就有可能出现编译错误，需要修改。因此，Rust 中的“宏”一直难以稳定。

所以，Rust 设计者希望提供一套相对稳定一点的 API，它基本跟 rustc 的内部数据结构解耦。这个设计就是 macro 2.0。这个功能目前暂时还没完成。但是，Rust 提前推出了一个 macro 1.1 版本。我们在 1.15 正式版中可以体验一下这个功能的概貌。
所谓的 macro 1.1 是按照 2.0 的思路专门为自动 derive 功能设计的，是一个缩微版的 macro 2.0。

在 Rust 中，attribute 也是一种特殊的宏。在编译器内部，attribute 和 macro 并没有本质的区别，它们都是所谓的编译器扩展。在以后的 macro 2.0 中，我们也可以用类似的 API 设计自定义 attribute。目前有一个叫作 derive 的 attribute 是最常用的，最需要支持自定义扩展。专门为支持自定义 derive 的功能，就是 macro 1.1。derive 功能我们在 trait 一章中已经讲过了，attribute 可以让编译器帮我们自动 impl 某些 trait。

目前，编译器的 derive 只支持一小部分固定的 trait。但我们可以通过自定义宏实现扩展 derive。下面，我们用一个示例来演示一下如何使用 macro 1.1 完成自定义`#[derive(HelloWorld)]`功能。

首先，需要把编译工具升级到最新的 nightly 版本。然后创建两个项目：一个是实现宏，一个使用宏。

---

```rust
$ cargo new --bin hello-world
$ cd hello-world
$ cargo new hello-world-derive
```

---

在 hello-world-derive 项目的`Cargo.toml`中，加上项目属性设置：

---

```rust
[lib]
proc-macro=true
```

---

在 hello-world 项目的`Cargo.toml`中，设置项目依赖：

---

```rust
[dependencies]
hello-world-derive = { path = "hello-world-derive" }
```

---

宏项目编译完成后，会生成一个动态链接库。这个库会被编译器在编译主项目的过程中调用。在主项目代码中写上如下测试代码：

---

```rust
#[macro_use]
extern crate hello_world_derive;

trait THelloWorld {
    fn hello();
}

#[derive(HelloWorld)]
struct FrenchToast;


fn main() {
    FrenchToast::hello();
}
```

---

接下来，我们来实现这个宏。它的代码骨架如下所示：

---

```rust
extern crate proc_macro;

use proc_macro::TokenStream;
use std::str::FromStr;

#[proc_macro_derive(HelloWorld)]
pub fn hello_world(input: TokenStream) -> TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    TokenStream::from_str("").unwrap()
}
```

---

我们的主要逻辑就写在`hello_world`函数中，它需要用`proc_macro_derive`修饰。它的签名是，输入一个 TokenStream，输出一个 TokenStream。这个 TokenStream 类型目前还没实现什么有用的成员方法，暂时只提供了和字符串类型之间的转换方式。我们在函数中把 input 的值打印出来：

---

```rust
let s = input.to_string();
println!("{}", s);
```

---

编译可见，输出值为 struct FrenchToast；。由此可见，编译器将`#[derive()]`宏修饰的部分作为参数，传递给了我们这个编译器扩展函数。我们需要对这个参数进行分析，然后将希望自动生成的代码作为返回值传递出去。

在这里，我们引入 regex 库来辅助实现逻辑。在项目文件中，加入以下代码：

---

```rust
[dependencies]
regex = "0.2"
```

---

然后写一个函数，把类型名字从输入参数中提取出来：

---

```rust
fn parse_struct_name(s: &str) -> String {
    let r = Regex::new(r"(?:struct\s+)([\w\d_]+)").unwrap();
    let caps = r.captures(s).unwrap();
    caps[1].to_string()
}

#[test]
fn test_parse_struct_name() {
    let input = "struct Foo(i32);";
    let name = parse_struct_name(input);
    assert_eq!(&name, "Foo");
}
```

---

接下来，就可以自动生成我们的 impl 代码了：

---

```rust
#[proc_macro_derive(HelloWorld)]
pub fn hello_world(input: TokenStream) -> TokenStream {
    let s = input.to_string();
    let name = parse_struct_name(&s);
    let output = format!(r#"
impl THelloWorld for {0} {{
    fn hello() {{ println!(" {0} says hello "); }}
}}"#, name);

    TokenStream::from_str(&output).unwrap()
}
```

---

我们构造了一个字符串，然后将这个字符串转化为 TokenStream 类型返回。

编译主项目可见，FrenchToast 类型已经有了一个`hello()`方法，执行结果为：

---

```rust
FrenchToast says hello
```

---

在 macro 1.1 版本中，只提供了这么一点简单的 API。在接下来的 macro 2.0 版本中，会为 TokenStream 添加一些更有用的方法，或许那时候就没必要把 TokenStream 转成字符串再自己解析一遍了。
