# 9.2 示范型宏

自定义宏有两种实现方式：

* 通过标准库提供的`macro_rules!`宏实现。

* 通过提供编译器扩展来实现。

编译器扩展只能在不稳定版本中使用。它的 API 正在重新设计中，还没有正式定稿，这就是所谓的 macro 2.0。在后面，我们会体验 macro 1.1，它就是 macro 2.0 的缩微版。

下面我们来使用一个例子讲解如何使用`macro_rules!`实现自定义宏。`macro_rules!`是标准库中为我们提供的一个编写简单宏的小工具，它本身也是用编译器扩展来实现的。它可以提供一种“示范型”（by example）宏编写方式。

举个例子，我们考虑一下这样的需求：提供一个`hashmap!`宏，实现如下初始化 HashMap 的功能：

---

```rust
let counts = hashmap!['A' => 0, 'C' => 0, 'G' => 0, 'T' => 0];
```

---

首先，定义 hashmap 这样一个宏名字：

---

```rust
macro_rules! hashmap {
}
```

---

在大括号里面，我们定义宏的使用语法，以及它展开后的形态。定义方式类似 match 语句的语法，`expander => { transcriber }`。左边的是宏扩展的语法定义，后面是宏扩展的转换机制。语法定义的标识符以$开头，类型支持 item、block、stmt、pat、expr、ty、itent、path、tt。
我们的需求是需要一个表达式，一个`=>`标识符，再跟一个表达式，因此，宏可以写成这样：

---

```rust
macro_rules! hashmap {
    ($key: expr => $val: expr) => {
        // 暂时空着
        ()
    }
}
```

---

现在我们已经实现了一个`hashmap! {'A'=>'1'};`这样的语法了。我们希望这个宏扩展开后的类型是 HashMap，而且进行了合理的初始化，那么我们可以使用“语句块”的方式来实现：

---

```rust
macro_rules! hashmap {
    ($key: expr => $val: expr) => {
        {
        let mut map = ::std::collections::HashMap::new();
        map.insert($key, $val);
        map
        }
    }
}
```

---

现在我们希望在宏里面，可以支持重复多个这样的语法元素。我们可以使用`+`模式和`*`模式来完成。类似正则表达式的概念，`+`代表一个或者多个重复，`*`代表零个或者多个重复。因此，我们需要把需要重复的部分用括号括起来，并加上逗号分隔符：

---

```rust
macro_rules! hashmap {
    ($( $key: expr => $val: expr ),*) => {{
        let mut map = ::std::collections::HashMap::new();
        map.insert($key, $val);
        map
    }}
}
```

---

最后，我们在语法扩展的部分也使用`*`符号，将输入部分扩展为多条 insert 语句。最终的结果如下所示：

---

```rust
macro_rules! hashmap {
    ($( $key: expr => $val: expr ),*) => {{
        let mut map = ::std::collections::HashMap::new();
        $( map.insert($key, $val); )*
        map
    }}
}

fn main() {
    let counts = hashmap!['A' => 0, 'C' => 0, 'G' => 0, 'T' => 0];

    println!("{:?}", counts);
}
```

---

一个自定义宏就诞生了。如果我们想检查一下宏展开的情况是否正确，可以使用如下`rustc`的内部命令：

---

```rust
rustc -Z unstable-options --pretty=expanded temp.rs
```

---

可以看到，`hashmap!`宏展开后的结果是：

---

```rust
let counts =
        {
            let mut map = ::std::collections::HashMap::new();
            map.insert('A', 0);
            map.insert('C', 0);
            map.insert('G', 0);
            map.insert('T', 0);
            map
        };
```

---

很大一部分宏的需求我们都可以通过这种方式实现，它比较适合写那种一个模子套出来的重复代码。
