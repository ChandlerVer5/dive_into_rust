### 10.2 段错误

我们再回忆一下 Rust 的主要特点。Rust 官方网站给自己的介绍是：

Rust is a systems programming language that runs blazingly fast，prevents segfaults，and guarantees thread safety.

本节就来讲一下什么是 segfault，以及什么是 Rust 所谈论的“内存安全”概念。

segfault 实际上是“segmentation fault”的缩写形式，我们可以翻译为“段错误”。segfault 是这样形成的：进程空间中的每个段通过硬件 MMU 映射到真正的物理空间；在这个映射过程中，我们还可以给不同的段设置不同的访问权限，比如代码段就是只能读不能写；进程在执行过程中，如果违反了这些权限，CPU 会直接产生一个硬件异常；硬件异常会被操作系统内核处理，一般内核会向对应的进程发送一条信号；如果没有实现自己特殊的信号处理函数，默认情况下，这个进程会直接非正常退出；如果操作系统打开了 core dump 功能，在进程退出的时候操作系统会把它当时的内存状态、寄存器状态以及各种相关信息保存到一个文件中，供用户以后调试使用。

在传统系统级编程语言 C/C++里面，制造 segfault 是很容易的。程序员需要非常小心才能避免这种错误，这也是为什么会有那么多的代码标准来规范程序员的行为。而另外一类编程语言规避 segfault 的办法是使用自动垃圾回收机制。在这些编程语言中，指针的能力被大幅限制，内存分配和释放都在一个运行时环境中被严格管理。当然，这么做也付出了一定的代价。某些应用场景下用这样的代价换取开发效率和安全性是非常划算的，而在某些应用场景下这样的代价是不可接受的。

Rust 的主要设计目标之一，是在不用自动垃圾回收机制的前提下避免产生 segfault。从这个意义上来说，它是独一无二的。至于它是如何做到的，本书将会详细剖析。
