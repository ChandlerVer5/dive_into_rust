# 7.1 简介

“Pattern Destructure”是 Rust 中一个重要且实用的设计。笔者暂且将其翻译为“模式解构”。注意这里的“Destructure”和“Destructor”是完全不同的两个单词，代表完全不同的含义。“Destructure”的意思是把原来的结构肢解为单独的、局部的、原始的部分；“Destructor”是指“析构器”，是一个与“构造器”相对应的概念，是在对象被销毁的时候调用的。

下面举例说明什么是模式解构：

---

```rust
let tuple = (1_i32, false, 3f32);
let (head, center, tail) = tuple;
```

---

以上的第二句代码就是一个典型的“模式解构”。我们可以这么理解，第一句话是“构造”，它把三个元素组合到了一起，形成了一个 tuple。而第二句代码则是刚好反过来，把一个组合数据结构，拆解开来，分成了三个不同的变量。在 let 语句中，赋值号左边的内容就是本节中我们所说的“模式”，赋值号右边的内容就是我们需要被“解构”的内容。这个“模式”中引入了三个新的变量 head、center、tail，它们分别绑定了这个 tuple 的三个成员。

Rust 中模式解构功能设计得非常美观，它的原则是：构造和解构遵循类似的语法，我们怎么把一个数据结构组合起来的，我们就怎么把它拆解开来。为了更好地说明这个问题，我们再来看一个更复杂一点的例子。比如，我们有一个 struct，里面包含另外一个 struct 类型：

---

```rust
struct T1 (i32, char);

struct T2 {
    item1: T1,
    item2: bool,
}

fn main()
{
    let x = T2 {
        item1: T1(0, 'A'),
        item2: false,
    };

    let T2 {
        item1: T1(value1, value2),
        item2: value3,
    } = x;

    println!("{} {} {}", value1, value2, value3);
}
```

---

如前所述，我们首先构造了一个 T2 类型的变量 x，它内部又嵌套包含了其他的结构体。实际上，我们完全可以一次性解构多个层次，直接把这个对象内部深处的元素拆解出来。第二条 let 语句，就是一个比较复杂的“模式解构”，赋值号的左边不仅仅是一个变量名，还是一个完整的“模式”，在这个模式中引入了三个变量 value1、value2、value3，分别绑定到了 item1 内部的两个成员以及 item2 上。

编译，执行，打印出来的结果为"0 A false"。

Rust 的“模式解构”功能不仅出现在 let 语句中，还可以出现在 match、if let、while let、函数调用、闭包调用等情景中。而 match 具有功能最强大的模式匹配。下面首先介绍 match 语法。
