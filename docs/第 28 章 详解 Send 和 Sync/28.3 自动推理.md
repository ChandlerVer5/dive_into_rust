### 28.3 自动推理

Send 和 Sync 是 marker trait。在 Rust 中，有一些 trait 是在 std::marker 模块中的特殊 trait。它们有一个共同的特点，就是内部都没有任何的方法，它们只用于给类型做“标记”。在 std::marker 这个模块中的 trait，都是给类型做标记的 trait。每一种标记都将类型严格切分成了两个组。

我们可以从源码中的 src/libcore/marker.rs 中看到：

---

```rust
unsafe impl Send for .. { }
unsafe impl Sync for .. { }
```

---

这是一个临时的、特殊的语法，它的含义是：针对所有类型，默认实现了 Send/Sync。使用了这种特殊语法的 trait 叫作 OIBIT（Opt-in built-in trait），后来改称为 Auto Trait。注意：这个语法是不稳定的，以后会改变。不管怎样，编译器留了一个后门，可以让我们定义 Auto Trait。

Auto Trait 有一个重要特点，就是编译器允许用户不用手写 impl，自动根据这个类型的成员“推理”出这个类型是否满足这个 trait。

我们可以手动指定这个类型满足这个 trait 约束，也可以手动指定它不满足这个 trait 约束，但是手动指定的时候，一定要用 unsafe 关键字。

比如，在标准库中就有这样的代码：

---

```rust
unsafe impl<T: ?Sized> !Send for *const T { }
unsafe impl<T: ?Sized> !Send for *mut T { }
unsafe impl<'a, T: Sync + ?Sized> Send for &'a T {}
unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}
    // 等等
```

---

使用！Send 这种写法表示“取反”操作，这些类型就一定不满足 Send 约束。

请大家一定要注意 unsafe 关键字。这个关键字在这里的意思是，编译器自己并没有能力正确地、智能地理解每一个类型的内部实现原理，并由此判断它是否满足 Send 或者 Sync。它需要程序员来提供这个信息。此时，编译器选择相信程序员的判断。但同时，这两个 trait 对于“线程安全”至关重要，如果程序员自己在这里判断错了，就可能制造出“线程不安全”的问题。

所以，这里的规则和前面讲的“内存安全”的情况是一样的。某些情况下，程序员需要做底层操作的时候，编译器没有能力判断这部分是不是满足内存安全，就需要程序员把这部分代码用 unsafe 关键字包起来，由程序员去负责安全性。unsafe 关键字的意义不是说这段代码“不安全”，而是说这段代码的安全性编译器自己无法智能检查出来，需要由程序员来保证。

标准库中把所有基本类型，以及标准库中定义的类型，都做了合适的 Send/Sync 标记。

同时，由于 Auto trait 这个机制的存在，绝大部分用户创建的自定义类型，本身都已经有了合理的 Send/Sync 标记，用户不需要手动修改它。只有一种情况例外：用户用了 unsafe 代码的时候，有些类型就很可能需要手动实现 Send/Sync。比如做 FFI，在 Rust 项目中调用 C 的代码。这种时候，类型内部很可能会包含一些裸指针，各种方法调用也会有许多 unsafe 代码块。此时，一个类型是否满足 Send/Sync 就不能依赖 Auto Trait 机制由编译器推理了，因为它推理出来的结论很可能是错的。程序员需要根据 Send/Sync 所表达的概念去理解这个类型的逻辑，然后自己判断出它是否满足 Send/Sync 的约束。在这种情况下，写这个库的程序员就成了实现“线程安全”目标的重要一环。如果写错了，就会对下游用户造成致命的影响，所有依赖于这个库的代码都有可能引发线程不安全。
