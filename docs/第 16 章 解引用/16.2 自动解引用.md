# 16.2 自动解引用

Rust 提供的“自动解引用”机制，是在某些场景下“隐式地”“自动地”帮我们做了一些事情。什么是自动解引用呢？下面用一个示例来说明：

---

```rust
fn main() {
    let s = "hello";
    println!("length: {}", s.len());
    println!("length: {}", (&s).len());
    println!("length: {}", (&&&&&&&&&&&&&s).len());
}
```

---

编译，成功。查文档我们可以知道，`len()`这个方法的签名是：

---

```rust
fn len(&self) -> usize
```

---

它接受的 receiver 参数是`&str`，因此我们可以用 UFCS 语法调用：

---

```rust
println!("length: {}", str::len(&s));
```

---

但是，如果我们使用`&&&&&&&&&&str`类型来调用成员方法，也是可以的。原因就是，Rust 编译器帮我们做了隐式的`deref`调用，当它找不到这个成员方法的时候，会自动尝试使用`deref`方法后再找该方法，一直循环下去。

编译器在`&&&str`类型里面找不到`len`方法；尝试将它`deref`，变成`&&str`类型后再寻找`len`方法，还是没找到；继续`deref`，变成`&str`，现在找到`len`方法了，于是就调用这个方法。

自动`deref`的规则是，如果类型 T 可以解引用为 U，即`T：Deref<U>`，则`&T`可以转为&U。
