# 18.4 小结

Rust 语言是跟 C++非常相似的一门语言。它们的定位相似，目标一致，都没有 GC，都面向底层硬件，都希望提供比较好的高级抽象能力，都对性能有非常高的要求。而这也意味着，在许多情况下，它们会碰到同样的问题，有着类似的设计思路。

Rust 跟 C++最大的区别在于，它彻底摆脱了 C/C++ 遗留下来的“前向兼容性”包袱，可以大刀阔斧地引入一些在其他语言中早已被证明了的优秀设计。Rust 在保持底层定位的同时，把关注点主要放在了“安全性”问题上。除了前面介绍的“内存安全”、“线程安全”，Rust 在“异常安全”方面的设计也非常不错，只是比较少用于拿出来宣传而已，毕竟只有 C++是跟 Rust 遭遇了类似的问题，其他自带 GC 的语言，在这个问题上基本没什么需要特别关注的。在这个问题上，Rust 通过一系列设计，将这个问题基本控制在了 unsafe 代码中。在 safe 代码部分，编译器会将可能发生异常安全的部分提示出来，让用户显式处理，用户基本不会由于不小心被这个问题“坑”到。

虽然 Rust 抛弃了“兼容性”这样一个巨大的负担，但是，这并不意味着设计这样一门语言是件轻松的事情。在“系统级”编程语言这个“紧箍咒”之下，很多看似简单的方面都需要权衡和妥协。比如，“易用性”“简洁性”总是永远排在“安全性”“性能”这样的目标后面。这也注定了 Rust 的内在复杂性并不低。

最后要强调的是，panic 并不意味着“内存不安全”，恰恰相反，它是阻止“内存不安全”的利器。内存不安全造成的问题比程序突然退出要严重得多。在即将发生内存不安全现象的时候，如果当时已经没有任何其他选择，panic 至少可以避免最坏情况的发生。然后我们可以很快发现事故的第一现场，从而修复代码，使其继续执行。
