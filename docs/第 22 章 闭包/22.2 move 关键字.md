# 22.2 move 关键字

以上变量捕获的规则都是针对只作为局部变量的闭包而准备的。有些时候，我们的闭包的生命周期可能会超过一个函数的范围。比如，我们可以将此闭包存储到某个数据结构中，在当前函数返回之后继续使用。这样一来，就可能出现更复杂的情况：在闭包被创建的时候，它通过引用的方式捕获了某些局部变量，而在闭包被调用的时候，它所指向的一些外部变量已经被释放了。示例如下：

---

```rust
fn make_adder(x: i32) -> Box<Fn(i32) -> i32> {
    Box::new(|y| x + y)
}

fn main() {
    let f = make_adder(3);

    println!("{}", f(1)); // 4
    println!("{}", f(10)); // 13
}
```

---

大家可以看到，函数 make\_adder 中有一个局部变量 x，按照前面所述的规则，它被闭包所捕获，而且可以使用引用&的方式完成闭包内部的逻辑，因此它是被引用捕获的。而闭包则作为函数返回值被传递出去了。于是，闭包被调用的时候，它内部的引用所指向的内容已经被释放了。这种情况，应该会出现典型的野指针问题，属于内存不安全的范畴。幸运的是，该程序在 Rust 中根本无法编译通过，错误信息为：

---

```rust
error: closure may outlive the current function, but it borrows `x`, which is owned by the current function [E0373]
```

---

信息提示得非常清晰，我们又可以感谢 Rust 帮我们发现了一个问题。

那么这种情况，我们应该怎样写才对呢？这里要介绍一个新的关键字 move，它的功能是用于修饰一个闭包。示例如下：

---

```rust
fn make_adder(x: i32) -> Box<Fn(i32) -> i32> {
    Box::new(move |y| x + y)
    // 注意这里 ^^^
}
```

---

加上 move 关键字之后，所有的变量捕获全部使用 by value 的方式。也就是说，编译器生成的匿名结构体内部看起来像是下面这样：

---

```rust
struct ClosureEnvironment {
    x: TYPE1,  //
    y: TYPE2,  // 这里没有 &TYPE,&mut TYPE，所有被捕获的外部变量所有权一律转移进闭包
    z: TYPE3,  //
}
```

---

所以，move 关键字可以改变闭包捕获变量的方式，一般用于闭包需要传递到函数外部（escaping closure）的情况。
