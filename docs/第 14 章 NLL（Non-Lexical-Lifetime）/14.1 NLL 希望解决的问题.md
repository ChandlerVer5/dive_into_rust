### 14.1 NLL 希望解决的问题

首先，我们来看几个简单的示例。

---

```rust
use std::ascii::AsciiExt;

fn foo() -> Vec<char> {
    let mut data = vec!['a', 'b', 'c']; // --+ 'scope
    capitalize(&mut data[..]);          //   |
//  ^~~~~~~~~~~~~~~~~~~~~~~~~ 'lifetime //   |
    data.push('d');                     //   |
    data.push('e');                     //   |
    data.push('f');                     //   |
    data                                //   |
//  <-----------------------------------------+
}

fn capitalize(data: &mut [char]) {
    for c in data {
        c.make_ascii_uppercase();
    }
}

fn main() {
    let v = foo();
    println!("{:?}", v);
}
```

---

这段代码是没有问题的。我们的关注点是 foo()这个函数，它在调用 capitalize 函数的时候，创建了一个临时的&mut 型引用，在它的调用结束后，这个临时的借用就终止了，因此，后面我们就可以再用 data 去修改数据。注意，这个临时的&mut 引用存在的时间很短，函数调用结束，它的生命周期就结束了。

但是，如果我们把这段代码稍作修改，问题就出现了：

---

```rust
fn foo() -> Vec<char> {
    let mut data = vec!['a', 'b', 'c']; // --+ 'scope
    let slice = &mut data[..];// <-----------+ 'lifetime
    capitalize(slice);                  //   |
    data.push('d');  //ERROR            //   |
    data.push('e');  //ERROR            //   |
    data.push('f');  //ERROR            //   |
    data             //ERROR            //   |
//  <-----------------------------------------+
}
```

---

在这段代码中，我们创建了一个临时变量 slice，保存了一个指向 data 的&mut 型引用，然后再调用 capitalize 函数，就出问题了。编译器提示为：

---

```rust
error[E0499]: cannot borrow `data` as mutable more than once at a time
```

---

这是因为，Rust 规定“共享不可变，可变不共享”，同时出现两个&mut 型借用是违反规则的。在编译器报错的地方，编译器认为 slice 依然存在，然而又使用 data 去调用 fn push（&mut self，value：T）方法，必然又会产生一个&mut 型借用，这违反了 Rust 的原则。在目前这个版本中，如果我们要修复这个问题，只能这样做：

---

```rust
fn foo() -> Vec<char> {
    let mut data = vec!['a', 'b', 'c']; // --+ 'scope
    {
        let slice = &mut data[..];      // <-------+ 'lifetime
        capitalize(slice);              //   |
    }// <------------------------------------+
    data.push('d');
    data.push('e');
    data.push('f');
    data
}
```

---

我们手动创建了一个代码块，让 slice 在这个子代码块中创建，后面就不会产生生命周期冲突问题了。这是因为，在早期的编译器内部实现里面，所有的变量，包括引用，它们的生命周期都是从声明的地方开始，到当前语句块结束（不考虑所有权转移的情况）。

这样的实现方式意味着每个引用的生命周期都是跟代码块（scope）相关联的，它总是从声明的时候被创建，在退出这个代码块的时候被销毁，因此可以称为 Lexical lifetime。而本章所说的 Non-Lexical lifetime，意思就是取消这个关联性，引用的生命周期，我们用另外的、更智能的方式分析。有了这个功能，上例中手动加入的代码块就不需要了，编译器应该能自动分析出来，slice 这个引用在 capitalize 函数调用后就再没有被使用过了，它的生命周期完全可以就此终止，不会对程序的正确性有任何影响，后面再调用 push 方法修改数据，其实跟前面的 slice 并没有什么冲突关系。

看了上面这个例子，可能有人还会觉得，显式的用一个代码块来规定局部变量的生命周期是个更好的选择，Non-Lexical-Lifetime 的意义似乎并不大。那我们再继续看看更复杂的例子。我们可以发现，Non-Lexical-Lifetime 可以打开更多的可能性，让用户有机会用更直观的方式写代码。比如下面这样的一个分支结构的程序：

---

```rust
fn process_or_default<K,V:Default>
    (map: &mut HashMap<K,V>, key: K)
{
    match map.get_mut(&key) { // -------------+ 'lifetime
        Some(value) => process(value),     // |
        None => {                          // |
            map.insert(key, V::default()); // |
            //  ^~~~~~ ERROR.              // |
        }                                  // |
    } // <------------------------------------+
}
```

---

这段代码从一个 HashMap 中查询某个 key 是否存在。如果存在，就继续处理，如果不存在，就插入一个新的值。目前这段代码是编译不过的，因为编译器会认为在调用 get\_mut（&key）的时候，产生了一个指向 map 的&mut 型引用，而且它的返回值也包含了一个引用，返回值的生命周期是和参数的生命周期一致的。这个方法的返回值会一直存在于整个 match 语句块中，所以编译器判定，针对 map 的引用也是一直存在于整个 match 语句块中的。于是后面调用 insert 方法会发生冲突。

当然，如果我们从逻辑上来理解这段代码，就会知道，这段代码其实是安全的。因为在 None 分支，意味着 map 中没有找到这个 key，在这条路径上自然也没有指向 map 的引用存在。但是可惜，在老版本的编译器上，如果我们希望让这段代码编译通过，只能绕一下。我们试一下做如下的修复：

---

```rust
fn get_default1<'m,K,V:Default>(
    map: &'m mut HashMap<K,V>,key: K)
  -> &'m mut V
{
    match map.get_mut(&key) { // -------------+ 'm
        Some(value) => return value,       // |
        None => { }                        // |
    }                                      // |
    map.insert(key, V::default());         // |
    //  ^~~~~~ ERROR (still)                  |
    map.get_mut(&key).unwrap()             // |
}                                          // v
```

---

实际上这个改动依然会编译失败。原因就在于 return 语句，get\_mut 时候对 map 的借用传递给了 Some（value），在 Some 这个分支内存在一个引用，指向 map 的某个部分，而我们又把 value 返回了，这意味着编译器认为，这个借用从 match 开始一直到退出这个函数都存在。因此后面的 insert 调用依然发生了冲突。接下来我们再做一次修复：

---

```rust
fn get_default2<'m,K,V:Default>(
    map: &'m mut HashMap<K,V>,
    key: K)
  -> &'m mut V
{
    if map.contains(&key) {
    // ^~~~~~~~~~~~~~~~~~ 'n
        return match map.get_mut(&key) { // + 'm
            Some(value) => value,        // |
            None => unreachable!()       // |
        };                               // v
    }

    // At this point, `map.get_mut` was never
    // called! (As opposed to having been called,
    // but its result no longer being in use.)
    map.insert(key, V::default()); // OK now.
    map.get_mut(&key).unwrap()
}
```

---

这次的区别在于，get\_mut 发生在一个子语句块中。在这种情况下，编译器会认为这个借用跟 if 外面的代码没什么关系。通过这种方式，我们终于绕过了 borrow checker。但是，为了绕过编译器的限制，我们付出了一些代价。这段代码，我们需要执行两次 hash 查找，一次在 contains 方法，一次在 get\_mut 方法，因此它有额外的性能开销。这也是为什么标准库中的 HashMap 设计了一个叫作 entry 的 api，如果用 entry 来写这段逻辑，可以这么做：

---

```rust
fn get_default3<'m,K,V:Default>(
    map: &'m mut HashMap<K,V>,
    key: K)
  -> &'m mut V
{
    map.entry(key)
        .or_insert_with(|| V::default())
}
```

---

这个设计既清晰简洁，也没有额外的性能开销，而且不需要 Non-Lexical-Lifetime 的支持。这说明，虽然老版本的生命周期检查确实有点过于严格，但至少在某些场景下，我们其实还是有办法绕过去的，不一定要在“良好的抽象”和“安全性”之间做选择。但是它付出了其他的代价，那就是设计难度更高，更不容易被掌握。标准库中的 entry API 也是很多高手经过很长时间才最终设计出来的产物。对于普通用户而言，如果在其他场景下出现了类似的冲突，恐怕大部分人都没有能力想到一个最佳方案，可以既避过编译器限制，又不损失性能。所以在实践中的很多场景下，普通用户做不到“零开销抽象”。

让编译器能更准确地分析借用指针的生命周期，不要简单地与 scope 相绑定，不论对普通用户还是高阶用户都是一个更合理、更有用的功能。如果编译器能有这么聪明，那么它应该能理解下面这段代码其实是安全的：

---

```rust
match map.get_mut(&key) {
        Some(value) => process(value), // 找到了就继续处理这个值
        None => {
            map.insert(key, V::default()); // 没找到 key 就插入一个新的值
        }
    }
```

---

这段代码既符合用户直观思维模式，又没有破坏 Rust 的安全原则。以前的编译器无法编译通过，实际上是对正确程序的误伤，是一种应该修复的缺陷。NLL 的设计目的就是让 Rust 的安全检查更加准确，减少误报，使得编译器对程序员的掣肘更少。

打开 NLL 功能，以下代码就可以编译通过了：

---

```rust
#![feature(nll)]

use std::collections::HashMap;

fn process_or_default4(map: &mut HashMap<String, String>, key: String)
{
    match map.get_mut(&key) {
        Some(value) => println!("{}", value),
        None => {
            map.insert(key, String::new());
        }
    }
}

fn main() {
    let mut map = HashMap::<String, String>::new();
    let key = String::from("abc");
    process_or_default4(&mut map, key);
}
```

---
